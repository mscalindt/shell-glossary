#! .desc:
# Modify a path
#! .params:
# <$1> - option_block(
#     'a' - resolve `.` lexically
#     'b' - resolve `..` lexically
#     'c' - strip consecutive slashes
#     'e' - discard inexistent segments
#     'f' - prepend slash
#     'g' - prepend slash on modified path
#     'j' - append join path without usage of slash
#     'k' - strip all trailing slashes if modified path not true directory
#     'l' - append slash (if not present) if modified path true directory
#     'n' - never return lexically root modified path
#     'o' - never return absolute modified path
#     'p' - never return relative modified path
#     'q' - never return inexistent modified path
#     'r' - prepend $PWD if relative
#     's' - discard symbolic segments
#     't' - strip all trailing slashes if not directory
#     'u' - strip all trailing slashes if modified path not directory
#     'v' - append slash (if not present) if directory
#     'w' - append slash (if not present) if modified path directory
#     'x' - strip all leading slashes
#     'y' - strip all trailing slashes
#     'z' - invert path
#     .
# )
# ["$2"] - absolute/relative path
# ["$3"] - join path
#! .uses.var:
# [PWD] $ - environment variable;
#           absolute pathname of the current working directory
#! .uses.fn:
# [assert] ("type" "string");
#          Assert a string
#! .gives:
# (0) <"$_path"> - [string];
#                  [modified <$2>]
#! .rc:
# (0) success
# (255) bad input
#.
path_spec_static() {
    [ "${1#\-}" ] || return 255

    # Assert the option block contains only expected options (characters).
    case "${1#\-}" in
        *[!abcefgjklnopqrstuvwxyz]*) return 255 ;;
    esac

    # Fuse $2 (path) and $3 (join path), if any.
    if [ "$2" ]; then
        _path="$2/$3"

        # Append $3 without the usage of a slash. (-j)
        case "$1" in
            *j*) _path="$2$3" ;;
        esac

        [ "$3" ] || _path="$2"
    else
        _path=; return 0
    fi

    # Set $_path to $3. From this point on, the path should only be modified
    # solely as a positional parameter. This allows safe usage of functions
    # that might inadvertently use or consume $_path.
    set -- "$1" "$2" "$_path"

    # Strip all leading slashes. (-x)
    case "$1" in
        *x*) set -- "$1" "$2" "${3#"${3%%[!/]*}"}" ;;
    esac

    # Strip all trailing slashes. (-y)
    case "$1" in
        *y*) set -- "$1" "$2" "${3%"${3##*[!/]}"}" ;;
    esac

    # Strip all trailing slashes if the path is not a directory. (-t)
    case "$1" in
        *t*) [ -d "$3" ] || set -- "$1" "$2" "${3%"${3##*[!/]}"}" ;;
    esac

    # Append a slash (if not present) if the path is a directory. (-v)
    case "$1" in
        *v*)
            case "$3" in
                *[!/]) [ ! -d "$3" ] || set -- "$1" "$2" "$3/" ;;
            esac
        ;;
    esac

    # If the passed path operand is relative, prepend $PWD. (-r)
    #
    # For more information, refer to:
    # > "POSIX.1-2024, Volume: Base Definitions, Section: Environment
    #   Variables, Subsection: Environment Variable Definition".
    # > "POSIX.1-2024, Volume: Base Definitions, Section: Environment
    #   Variables, Subsection: Other Environment Variables".
    case "$1" in
        *r*) assert -absolute-path "$3" || set -- "$1" "$2" "${PWD%/}/$3" ;;
    esac

    # Prepend a slash. (-f)
    case "$1" in
        *f*) set -- "$1" "$2" "/$3" ;;
    esac

    # Move $3 to $2 and rebuild $3 (modified path) from $2.
    #
    # When discard or resolve operations take place, if $3 ends up empty on the
    # last segment processed, root (`/`) will be the default location
    # resolved/discarded to. This behavior aligns with the POSIX specification,
    # but can be mitigated with option `-n`.
    #
    # For more information, refer to:
    # > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
    #   Subsection: Pathname Resolution".
    set -- "$1" "$3" ""; while [ "$2" ]; do
        # Example path:
        # `//abc///foo`
        # $_pfx: `//`
        # $_segment: `abc`
        _pfx="${2%%[!/]*}"
        _segment="${2#"$_pfx"}"
        _segment="${_segment%%/*}"

        # Strip $_pfx (prefix) and $_segment (path segment) from $2.
        set -- "$1" "${2#"$_pfx$_segment"}" "$3"

        if [ "$_segment" = '.' ]; then
            # Resolve `.` lexically. (-a)
            case "$1" in
                *a*)
                    # As `.` is ambiguous and as stated, when both $2
                    # (segments) and $3 (modified path) are empty, the default
                    # standard resolving behavior is "resolve to root".
                    _segment=
                    { [ "$2" ] || [ "$3" ]; } && continue || _pfx=/
                ;;
            esac
        elif [ "$_segment" = '..' ]; then
            # Resolve `..` lexically. (-b)
            case "$1" in
                *b*)
                    # As `..` is ambiguous and as stated, when both $2
                    # (segments) and $3 (modified path) are empty, the default
                    # standard resolving behavior is "resolve to root".
                    set -- "$1" "$2" "${3%/*}"
                    set -- "$1" "$2" "${3%"${3##*[!/]}"}"
                    [ "$2" ] || [ "$3" ] || set -- "$1" "$2" /
                    continue
                ;;
            esac
        fi

        if [ "$_segment" ]; then
            # Discard inexistent segments. (-e)
            case "$1" in
                *e*)
                    # As stated, when both $2 (segments) and $3 (modified path)
                    # are empty, the default discarding behavior is "discard to
                    # root".
                    if [ ! -e "$3$_pfx$_segment" ]; then
                        _segment=
                        { [ "$2" ] || [ "$3" ]; } && continue || _pfx=/
                    fi
                ;;
            esac

            # Discard symbolic segments. (-s)
            case "$1" in
                *s*)
                    # As stated, when both $2 (segments) and $3 (modified path)
                    # are empty, the default discarding behavior is "discard to
                    # root".
                    if [ ! -h "$3$_pfx$_segment" ]; then
                        _segment=
                        { [ "$2" ] || [ "$3" ]; } && continue || _pfx=/
                    fi
                ;;
            esac
        fi

        if [ "$_pfx" ]; then
            # Strip consecutive slashes. (-c)
            case "$1" in
                *c*) _pfx=/ ;;
            esac
        fi

        # Unless option `-z` (invert path) is specified, append modified $_pfx
        # (prefix) and $_segment (path segment) to $3 (modified path).
        # Otherwise, prepend them. (-z)
        case "$1" in
            *z*) set -- "$1" "$2" "$_segment$_pfx$3" ;;
            *) set -- "$1" "$2" "$3$_pfx$_segment" ;;
        esac
    done

    # Strip all trailing slashes if the modified path is not a directory. (-u)
    case "$1" in
        *u*) [ -d "$3" ] || set -- "$1" "$2" "${3%"${3##*[!/]}"}" ;;
    esac

    # Append a slash (if not present) if the modified path is a directory. (-w)
    case "$1" in
        *w*)
            case "$3" in
                *[!/]) [ ! -d "$3" ] || set -- "$1" "$2" "$3/" ;;
            esac
        ;;
    esac

    # Strip all trailing slashes if the modified path is not a true directory.
    # A true directory is a directory that is not a symbolic link.
    # (-k)
    #
    # Any trailing slashes will be removed for operator `-h` of `test`, because
    # otherwise they will cause an actual symbolic link to be followed and thus
    # deteriorate the reliability of `-h`.
    #
    # For more information, refer to:
    # > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
    #   Subsection: Pathname Resolution".
    case "$1" in
        *k*)
            # If $3 is a directory and a symbolic link, it is "not a true
            # directory".
            [ ! -d "$3" ] || \
            [ ! -h "${3%"${3##*[!/]}"}" ] || \
            set -- "$1" "$2" "${3%"${3##*[!/]}"}"
        ;;
    esac

    # Append a slash (if not present) if the modified path is a true directory.
    # A true directory is a directory that is not a symbolic link.
    # (-l)
    case "$1" in
        *l*)
            case "$3" in
                *[!/])
                    # If $3 is a directory and is not a symbolic link, it is "a
                    # true directory".
                    [ ! -d "$3" ] || \
                    [ -h "$3" ] || \
                    set -- "$1" "$2" "$3/"
                ;;
            esac
        ;;
    esac

    # Prepend a slash on the modified path. (-g)
    case "$1" in
        *g*) set -- "$1" "$2" "/$3" ;;
    esac

    # Never return lexically root modified path. (-n)
    case "$1" in
        *n*)
            if [ "$3" ] && [ "${3#"${3%%[!/]*}"}" = '' ]; then
                _path=; return 0
            fi
        ;;
    esac

    # Never return absolute modified path. (-o)
    case "$1" in
        *o*) assert -relative-path "$3" || { _path=; return 0; } ;;
    esac

    # Never return relative modified path. (-p)
    case "$1" in
        *p*) assert -absolute-path "$3" || { _path=; return 0; } ;;
    esac

    # Never return inexistent modified path. (-q)
    case "$1" in
        *q*) [ -e "$3" ] || { _path=; return 0; } ;;
    esac

    _path="$3"; return 0
}

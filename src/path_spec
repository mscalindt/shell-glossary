#! .desc:
# Normalize a path into an assertable path specification
#! .params:
# <"$1"> - absolute path
# ["$2"] - join path
#! .uses:
# <assert> ('-absolute-path' '$1');
#          Assert a string
#! .gives:
# (0) <"$_path"> - string;
#                  [modified <$1>]
#! .rc:
# (0) success
# (1) bad path resolution
# (255) bad input
#.
path_spec() {
    # Assert $1 is an absolute path.
    assert -absolute-path "$1" || return 255

    # Save $IFS.
    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    # Save the state of the pathname expansion flag and disable it if active;
    # disabled to disable the expansion of `*`.
    #
    # For more information, refer to:
    # > "POSIX.1-2017, Volume: Shell & Utilities, Section: Shell Command
    #   Language, Subsection: Pathname Expansion".
    case "$-" in
        *'f'*) _pn=0 ;;
        *) _pn=1; set -f ;;
    esac

    # Field split $1 (path) and $2 (join path) based on `/`.
    #
    # For more information, refer to:
    # > "POSIX.1-2017, Volume: Shell & Utilities, Section: Shell Command
    #   Language, Subsection: Field Splitting".
    IFS='/'; set -- $1/$2

    # Restore the active state of the pathname expansion flag if appropriate.
    if [ "$_pn" = 1 ]; then
        set +f
    fi

    # Restore $IFS.
    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null

    _path=; for _segment in "$@"; do
        # Skip empty arguments. Our case of field splitting (the method used to
        # turn the path into individual segments) produces empty arguments on
        # consecutive delimiter appearances.
        [ "$_segment" ] || continue

        # Resolve the path.
        # `.`: special directory name denoting the current directory.
        # `..`: special directory name denoting the parent directory.
        case "$_segment" in
            '.') continue ;;
            '..') _path="${_path%/*}" ;;
            *) _path="$_path/$_segment" ;;
        esac

        # Assert the path resolution is valid. Paths that attempt to resolve
        # above their root at any point in resolution are intentionally
        # rejected.
        [ "$_path" ] || return 1
    done

    # If the path is resolved to a true directory (not a symbolic link), add a
    # trailing slash to align it with the directory specification.
    if [ ! -h "$_path" ] && [ -d "$_path" ]; then
        _path="$_path/"
    fi
}

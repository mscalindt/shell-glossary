#! .desc:
# Check a bit, the power of 2, in a pseudo-bitmask shell variable
#! .params:
# <$1> - variable name
# <$2> - bit
#! .rc:
# (0) true
# (1) false
# (255) bad input/usage
#.
mask_check() {
    # Remove `0x` from $2 (bit) if present.
    set -- "$1" "${2#0x}"

    # Assert $1 is a valid shell variable name. The character classes have been
    # intentionally expanded to be locale-independent.
    case "$1" in
        [0123456789]*)
            return 255
        ;;
        *[!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_]*)
            return 255
        ;;
    esac

    # Assert $2 is a natural number and a valid bit.
    case :"$2${2#*[!0123456789]}" in
        : | :0*) return 255 ;;
        :"$2$2") [ "$(($2 & ($2 - 1)))" -eq 0 ] || return 255 ;;
        *) return 255 ;;
    esac

    # Safely evaluate $1 (variable name) into its literal content.
    eval set -- "\$$1" "$2"

    # Assert the variable expanded to a whole number. If the variable was/has
    # evaluated empty, due to the `eval` construct used, $1 would take the
    # value of $2, therefore $2 has to be asserted before the number assert
    # takes place.
    [ "$2" ] || return 255
    case :"$1${1#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    # Assert whether $2 (the specified bit) is set in $1 (the bitmask).
    [ "$(($1 & $2))" -eq "$2" ]
}

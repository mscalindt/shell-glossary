#! .desc:
# Convert N to that amount of character(s)
#! .params:
# <$1> - N
# <"$2"> - character(s)
#! .uses.fn:
# <assert> ('-whole-n' '$1');
#          Assert a string
#! .gives:
# (0) <"$_chars"> - [string]
#! .rc:
# (0) success
# (255) bad input
#! .rc.fn:
# (assert) (255) bad input
#.
num_to_char() {
    # Handle negative N ($1) gracefully: $_chars is set to an empty string and
    # success is returned.
    case "$1" in
        '-'[0123456789]*) _chars=; return 0 ;;
    esac

    assert -whole-n "$1" || return 255

    # Repeat the character(s) ($2) N times ($1) to create the desired string.
    # When N is `0`, no characters are created, and $_chars is set to an empty
    # string. This helps in seamlessly integrating the function in cases where
    # character generation is not needed.
    _chars=; _i=0; until [ "$_i" = "$1" ]; do
        _chars="$_chars$2"; _i=$((_i + 1))
    done

    return 0
}

#! .desc:
# Read a file raw
#! .params:
# <"$1"> - absolute file path
# <$2> - method(
#     '-subshell' - use command substitution
#     '-var' - use string concatenation
#     .
# )
#! .uses:
# [&9]
#! .uses.util:
# [cat];
# concatenate and print files
#! .gives:
# (0) <"$_file"> - raw content of the file
#! .rc:
# (0) success
# (*) error
# (255) bad input / bad usage
#! .rc.util
# (cat) (*) error
#.
file_preload() {
    # For flexibility and modularity, missing files will not be signaled.
    [ -f "$1" ] || { _file=; return 0; }

    # Use `cat` to read the file into $_file if $1 is a potential specification
    # of a file in `/dev`, `/proc`, or `/sys` (kernel-created virtual file).
    #
    # `cat` will read the file in one `read` syscall. This is important because
    # certain kernel files can only be read() once, returning EOF on subsequent
    # read() syscalls. This behavior is prevalent for certain files in `/proc`
    # which do not support seeking.
    #
    # `cat` reads a file in large chunks, accommodating the requirement for a
    # single read(). This contrasts with a POSIX shell, which reads files one
    # byte at a time and may only return the first byte of data from certain
    # kernel files.
    case "/$1" in
        *'/dev/'* | *'/proc/'* | *'/sys/'*)
            # Store the output of `cat` in $_file using command substitution.
            # The custom `x` character at the end and its subsequent removal
            # outside the command substitution preserves any trailing <newline>
            # characters stripped by command substitution.
            #
            # For more information, refer to:
            # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell
            #   Command Language, Subsection: Command Substitution".
            _file=$(cat "$1" && printf "%s" 'x') || return "$?"
            _file="${_file%?}" && return 0 || return "$?"
        ;;
    esac

    # Open the file specified by $1 and assign it to file descriptor `9`. The
    # usage of a file descriptor simplifies the error handling and allows for a
    # more uniform parsing. Additionally, TOCTOU flaws are completely avoided
    # this way.
    { exec 9< "$1"; } || return "$?"

    # Read the file with the specified method.
    # `-subshell` performs better on big files.
    # `-var` performs better on small files.
    case "$2" in
        '-subshell')
            # Store the output of each `printf` in $_file using command
            # substitution. The custom `x` character at the end and its
            # subsequent removal outside the command substitution preserves any
            # trailing <newline> characters stripped by command substitution.
            #
            # For more information, refer to:
            # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell
            #   Command Language, Subsection: Command Substitution".
            _file=$(
                while IFS= read -r _line <&9; do
                    printf "%s\n" "$_line"
                done; printf "%s" "${_line}x"
            )
            _file="${_file%?}"
        ;;
        '-var')
            # Append with <newline> each $_line to an initially empty $_file to
            # build the raw content of the file.
            _file=; while IFS= read -r _line <&9; do
                _file="$_file$_line
"
            done; _file="$_file$_line"
        ;;
        *)
            exec 9<&- && return 255 || return "$?"
        ;;
    esac

    # Release file descriptor `9` to close the associated file.
    exec 9<&-
}

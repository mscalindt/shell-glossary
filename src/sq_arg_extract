#! .desc:
# Extract a single-quoted argument, in a single-quote-escaped string, by token
#! .params:
# <"$1"> - token
# <"$2"> - single-quote-escaped string
# [$3] - match_type(
#     '-exact' - $1 is the literal argument
#     '-prefix' - $1 is the prefix of an argument
#     '-suffix' - $1 is the suffix of an argument
#     .
# )
#! .gives:
# (0) <"$_arg"> - string;
#                 evaluated argument
#! .rc:
# (0) success
# (1) argument does not exist
# (255) bad input
#.
sq_arg_extract() {
    # Assert $2 is a valid single-quote-escaped string.
    # Example 1: `'a'\''' 'b'`.
    # Example 2: `'a' 'b'`.
    # Example 3: `'a'`
    _str="$2"; while :; do
        # $_str 1: `a'\''' 'b'`
        # $_str 2: `a' 'b'`
        # $_str 3: `a'`
        _str="${_str#\'}"

        while [ "$_str" ]; do
            # $_str 1: `\''' 'b'` -> `' 'b'` -> ` 'b'`
            # $_str 2: ` 'b'`
            # $_str 3: ``
            case "${_str#*\'}" in
                \\\'\'*) _str="${_str#*\'\\\'\'}"; continue ;;
                \ \'*) _str="${_str#*\'\ }"; continue 2 ;;
                '') break 2 ;;
            esac

            break
        done

        return 255
    done

    # Extract the specified argument. The usage of `eval` here is safe because
    # $2 has been asserted as a strict single-quote-escaped string.
    case "$3" in
        '-exact')
            _token="$1"; eval set -- "$2"; while [ "$#" -ge 1 ]; do
                case "$1" in
                    "$_token") _arg="$1"; return 0 ;;
                    *) shift && continue ;;
                esac
            done
        ;;
        '-prefix')
            _token="$1"; eval set -- "$2"; while [ "$#" -ge 1 ]; do
                case "$1" in
                    "$_token"*) _arg="$1"; return 0 ;;
                    *) shift && continue ;;
                esac
            done
        ;;
        '-suffix')
            _token="$1"; eval set -- "$2"; while [ "$#" -ge 1 ]; do
                case "$1" in
                    *"$_token") _arg="$1"; return 0 ;;
                    *) shift && continue ;;
                esac
            done
        ;;
        *)
            _token="$1"; eval set -- "$2"; while [ "$#" -ge 1 ]; do
                case "$1" in
                    *"$_token"*) _arg="$1"; return 0 ;;
                    *) shift && continue ;;
                esac
            done
        ;;
    esac

    return 1
}

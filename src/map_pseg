#! .desc:
# Process all segments of a path with a function
#! .params:
# <"$1"> - absolute/relative path
# <$2> - function name
# <"$3"+> - function arguments
#! .uses.fn:
# <path_spec_static> ('-cxy' '$1');
#                    Modify a path
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# ($2) (0) success
# ($2) (*) error
# (path_spec_static) (*) error
#! .caveats:
# > `ARG_MAX`.
# > `INT_MAX`.
#.
map_pseg() {
    # Assert a path segment to process exists and remove consecutive slashes in
    # $1 to prevent empty segments from being produced by the field splitting.
    path_spec_static -cxy "$1" || return "$?"  # -> $_path
    [ "$_path" ] || return 0
    shift && set -- "$_path" "$@"

    # Save $IFS.
    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    # Save the state of the pathname expansion flag and disable it if active;
    # disabled to disable the expansion of `*`.
    #
    # For more information, refer to:
    # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command
    #   Language, Subsection: Pathname Expansion".
    case "$-" in
        *'f'*) _pn=0 ;;
        *) _pn=1; set -f ;;
    esac

    # Field split $1 (path) based on `/`. The positional parameters are
    # reassigned such that $2 (function name) and any function arguments become
    # $1, while the produced arguments are the remaining positional parameters.
    #
    # For more information, refer to:
    # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command
    #   Language, Subsection: Field Splitting".
    IFS='/'; _path="$1"; shift; set -- "$@" $_path

    # Restore the active state of the pathname expansion flag if appropriate.
    if [ "$_pn" = 1 ]; then
        set +f
    fi

    # Restore $IFS.
    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null

    # The receiver function doesn't have to account for empty positional
    # parameters.
    "$@"
}

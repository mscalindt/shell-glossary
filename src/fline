#! .desc:
# Get a specific line in a file
#! .params:
# <$1> - read_method(
#     '-' - read heredoc (stdin)
#     '-cat' - use `cat`
#     '-shell' - use shell input redirection
#     .
# )
# <$2> - line number
# ["$3"] - file path
#! .uses:
# [&9]
# [()]
# [<<]
# [<]
#! .uses.fn:
# <assert> ('-natural-n' '$2');
#          Assert a string
# [file_preload] ('-cat' '$3');
#                Read a file raw
#! .uses.util:
# [cat] ('--' '$3');
#       concatenate and print files
#! .gives:
# (0) <"$_line"> - [string];
#                  specified line of $3/stdin
#! .rc:
# (0) success
# (1) line does not exist / error
# (*) error
# (255) bad input / error
#! .rc.fn:
# (assert) (255) bad input
# (file_preload) (*) error
#! .rc.util
# (cat) (*) error
#! .desc.ext:
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Command Substitution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Here-Document".
#.
fline() {
    assert -natural-n "$2" || return 255

    # Read the file with the specified method.
    #
    # Use `cat` to read the file if it is a potential specification of a file
    # in `/dev`, `/proc`, or `/sys` (kernel-created virtual file). Otherwise,
    # use the shell.
    case "$1" in
        '-')
            # Consume stdin using `read`, counting the lines;
            # if we land on the specified one, signal it.
            _i=1; while IFS= read -r _line; do
                case "$_i" in "$2") return 0 ;; esac
                _i=$((_i + 1))
            done
        ;;
        '-cat')
            {
                file_preload -cat "$3" && \
                fline - "$2" \
<<_
$_file
_
            } && return 0 || return "$?"
        ;;
        '-shell')
            # Open the file and assign it to file descriptor `9`. The usage of
            # a file descriptor simplifies the error handling. Additionally,
            # TOCTOU flaws are completely avoided this way.
            { exec 9< "$3"; } || return "$?"

            # Read the file, counting the lines;
            # if we land on the specified one,
            # release file descriptor `9` and signal the line.
            _i=1; while IFS= read -r _line <&9; do
                case "$_i" in "$2") exec 9<&-; return "$?" ;; esac
                _i=$((_i + 1))
            done; case "$_i" in "$2") exec 9<&-; return "$?" ;; esac

            # Release file descriptor `9` to close the associated file.
            exec 9<&-
        ;;
        *)
            return 255
        ;;
    esac

    return 1
}

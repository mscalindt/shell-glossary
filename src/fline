#! .desc:
# Get a specific line in a file
#! .params:
# <$1> - line number
# <"$2"> - absolute file path
#! .uses:
# [&9]
#! .uses.fn:
# <assert> ('-natural-n' '$1');
#          Assert a string
#! .uses.util:
# [cat];
# concatenate and print files
#! .gives:
# (0) <"$_line"> - string
#! .rc:
# (0) success
# (1) line does not exist / error
# (*) error
# (255) bad usage / error
#! .rc.fn:
# (assert) (255) bad input
#! .rc.util
# (cat) (*) error
#! .caveats:
# > `INT_MAX`.
#.
fline() {
    assert -natural-n "$1" || return 255

    # Assert $2 exists and is a file.
    [ -f "$2" ] || return 255

    # Use `cat` to read the file into $_line if $2 is a potential specification
    # of a file in `/dev`, `/proc`, or `/sys` (kernel-created virtual file).
    #
    # `cat` will read the file in one `read` syscall. This is important because
    # certain kernel files can only be read() once, returning EOF on subsequent
    # read() syscalls. This behavior is prevalent for certain files in `/proc`
    # which do not support seeking.
    #
    # `cat` reads a file in large chunks, accommodating the requirement for a
    # single read(). This contrasts with a POSIX shell, which reads files one
    # byte at a time and may only return the first byte of data from certain
    # kernel files.
    case "/$2" in
        *'/dev/'* | *'/proc/'* | *'/sys/'*)
            # Store the output of `cat` in $_line using command substitution.
            # The custom `x` character at the end and its subsequent removal
            # outside the command substitution preserves any trailing <newline>
            # characters stripped by command substitution.
            #
            # For more information, refer to:
            # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell
            #   Command Language, Subsection: Command Substitution".
            _line=$(cat "$2" && printf "%s" 'x') || return "$?"
            _line="${_line%?}"

            # Iterate over the lines of $_line using heredoc.
            #
            # For more information, refer to:
            # > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell
            #   Command Language, Subsection: Here-Document".
            _i=1; while IFS= read -r _line; do
                case "$_i" in
                    "$1") return 0 ;;
                esac

                _i=$((_i + 1))
            done \
<<_LINE
$_line
_LINE
        ;;
    esac

    # Open the file specified by $2 and assign it to file descriptor `9`. The
    # usage of a file descriptor simplifies the error handling. Additionally,
    # TOCTOU flaws are completely avoided this way.
    { exec 9< "$2"; } || return "$?"

    # Read the file, counting the lines; if we land on the specified one,
    # release file descriptor `9` and signal it.
    _i=1; while IFS= read -r _line <&9 || [ "$_line" ]; do
        case "$_i" in
            "$1") exec 9<&-; return "$?" ;;
        esac

        _i=$((_i + 1))
    done

    # Release file descriptor `9` to close the associated file and signal the
    # specified line doesn't exist.
    exec 9<&- && return 1
}

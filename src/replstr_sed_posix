#! .desc:
# Replace a substring with character(s) in a string using `sed`
#! .params:
# <$1> - substring
# [$2] - character(s)
# [$3] - string
#! .gives.var:
# (0) <_str> - [string];
#              [modified <$3>]
#! .rc:
# (0) success
# (*) error
#! .ec:
# (255) input error
#! .desc.ext:
# $1 cannot contain a <newline> character.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Command Substitution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Utilities,
#   Utility: sed".
#.
replstr_sed_posix() {
    [ "$1" ] || exit 255

    # Substring cannot contain <newline>.
    case "$1" in
        *'
'*)
            exit 255
        ;;
    esac

    [ "$3" ] || { _str=; return 0; }

    { esc_sed -RE / "$1" && set -- "$_str" "$2" "$3"; } && \
    { esc_sed -replacement / "$2" && set -- "$1" "$_str" "$3"; } || return "$?"

    # Store the output of `sed` in $_str using command substitution.
    # The custom `x` character at the end and its subsequent removal
    # outside the command substitution preserves any trailing <newline>
    # characters stripped by command substitution.
    _str=$({ printf "%s" "$3" | sed "s/$1/$2/g"; } && printf "%s" x) && \
    _str="${_str%?}"
}

#! .desc:
# Get N single-quoted argument in a single-quote-escaped string
#! .params:
# <$1> - "N"_arg(
#     '0' - last
#     .
# )
# <"$2"> - single-quote-escaped string
#! .uses:
# <assert> ('-whole-n' '$1');
#          Assert a string
#! .gives:
# (0) <"$_arg"> - string;
#                 evaluated argument
#! .rc:
# (0) success
# (1) argument does not exist
# (255) bad input
#.
sq_arg() {
    assert -whole-n "$1" || return 255

    # Assert $2 is a valid single-quote-escaped string.
    # Example 1: `'a'\''' 'b'`.
    # Example 2: `'a' 'b'`.
    # Example 3: `'a'`
    _str="$2"; while :; do
        # $_str 1: `a'\''' 'b'`
        # $_str 2: `a' 'b'`
        # $_str 3: `a'`
        case "$_str" in
            \'*) _str="${_str#?}" ;;
            *) return 255 ;;
        esac

        while [ "$_str" ]; do
            # $_str 1: `\''' 'b'` -> `' 'b'` -> ` 'b'`
            # $_str 2: ` 'b'`
            # $_str 3: ``
            case "${_str#*\'}" in
                \\\'\'*) _str="${_str#*\'\\\'\'}"; continue ;;
                \ \'*) _str="${_str#*\'\ }"; continue 2 ;;
                '') break 2 ;;
                *) return 255 ;;
            esac
        done

        return 255
    done

    # Extract the specified argument. The usage of `eval` here is safe because
    # $2 has been asserted as a strict single-quote-escaped string.
    _i=1; _n="$1"; eval set -- "$2"; while [ "$#" -ge 1 ]; do
        [ "$_i" -eq "$_n" ] || { _i=$((_i + 1)); shift && continue; }

        _arg="$1"; return 0
    done

    return 1
}

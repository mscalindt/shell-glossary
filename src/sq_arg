#! .desc:
# Get N single-quoted argument in a single-quote-escaped string
#! .params:
# <$1> - "N"_arg(
#     '0' - last
#     .
# )
# <"$2"> - single-quote-escaped string
#! .gives:
# (0) <"$_arg"> - string;
#                 single-quote-escaped argument
#! .rc:
# (0) success
# (1) argument does not exist
# (255) bad input
#.
sq_arg() {
    # Assert $1 is a whole number.
    case :"$1${1#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    # Iterate over $2/$_str (the single-quote-escaped arguments) until the
    # desired or the last one is reached.
    _i=0; _str="$2"; while :; do
        # `break` if the desired argument is reached.
        _i=$((_i + 1)); [ "$_i" -ne "$1" ] || break

        # "shift" the argument (strip the first argument) from $_str.
        case "$_str" in
            *\'\ \'*)
                # To properly shift the argument, the escape sequence of `' '`,
                # `'\'' '\''`, must also be properly distinguished amidst the
                # argument delimiter, `' '` again.
                _arg="$_str"; while :; do
                    # Here, if `\''` matches after stripping up to the first
                    # `' '`, we are in the middle of an escape sequence of
                    # `' '`; this match is reproducible as long as we don't
                    # encounter the actual `' '` argument delimiter, so just
                    # "continue" doing it.
                    #
                    # To prevent infinite looping, the string assert acts as a
                    # sanity check that the parameter expansion actually
                    # expanded; in POSIX and most shells, invalid parameter
                    # expansion produces the original string being evaluated.
                    case "${_str#*\' \'}" in
                        "$_str") : ;;
                        \\\'\'*) _str="${_str#*\' \'}"; continue ;;
                    esac

                    # Here, it is known the next `' '`, if present, is the
                    # delimiter between the current and the next argument;
                    # strip up to it to effectively shift the current argument.
                    case "$_str" in
                        *\'\ \'*) _str="'${_str#*\' \'}"; continue 2 ;;
                    esac

                    # Here, it means we already are on the last argument. But
                    # notably, $_str has to be restored to the state ($_arg)
                    # before this `' '` parse loop to account for any
                    # stripping done due to the escape sequence(s) of `' '`
                    # that could be present in the argument.
                    _str="$_arg"; break
                done
            ;;
        esac

        # Here, what remained of $_str is the last argument. If the desired
        # argument was not reached and the last argument is not wished for,
        # return `1` to indicate failure in reaching the desired argument.
        if [ "$1" -eq 0 ]; then
            break
        else
            return 1
        fi
    done

    # Set the desired argument as the first and sole positional parameter of
    # the function.
    set -- "$_str"; case "$1" in
        *\'\ \'*)
            # To properly extract the first argument from $_str, which could
            # contain multiple arguments, the escape sequence of `' '`,
            # `'\'' '\''`, must also be properly distinguished amidst the
            # argument delimiter, `' '` again.
            while :; do
                # Here, if `\''` matches after stripping up to the first `' '`,
                # we are in the middle of an escape sequence of `' '`; this
                # match is reproducible as long as we don't encounter the
                # actual `' '` argument delimiter, so just "continue" doing it.
                #
                # To prevent infinite looping, the string assert acts as a
                # sanity check that the parameter expansion actually expanded;
                # in POSIX and most shells, invalid parameter expansion
                # produces the original string being evaluated.
                case "${_str#*\' \'}" in
                    "$_str") : ;;
                    \\\'\'*) _str="${_str#*\' \'}"; continue ;;
                esac

                # Here, it is known the next `' '`, if present, is the
                # delimiter between the current and the next argument; delimit
                # the first argument by effectively stripping everything that
                # comes after it.
                case "$_str" in
                    *\'\ \'*) set -- "${1%"' '${_str#*\' \'}"}'"; break ;;
                esac

                # Here, there is nothing to be done. The original $_str (now
                # $1) already is a sole argument that just contained escape
                # sequence(s) of `' '`.
                break
            done
        ;;
    esac

    # Assert $1 is a valid single-quote-escaped argument.
    _arg="$1"; case "$_arg" in
        \'*\')
            # Strip the base single quote characters.
            _arg="${_arg#?}"
            _arg="${_arg%?}"

            # Verify whether every single quote is a proper escape sequence
            # (`'\''`) for a single quote character.
            while :; do case "$_arg" in
                *\'*)
                    _arg="${_arg#*\'}"; case "$_arg" in
                        "\\''"*) _arg="${_arg#???}" ;;
                        *) return 255 ;;
                    esac
                ;;
                *)
                    break
                ;;
            esac done
        ;;
        *)
            return 255
        ;;
    esac

    # Store the single-quote-escaped argument in $_arg.
    _arg="$1"
}

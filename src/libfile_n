#! .desc:
# Deterministically modify regular file data in-memory
#! .params:
# <$1>+ - operation(
#     '-' - at EOF add $2
#     '-a' - at line $2 add $3
#     '-r' - remove line $2
#     '-s' - substitute line $2 with $3
#     .
# )
# <"$2"> - natural N / string
# ["$3"] - string
# ["$4"] - file content
# ["$5"] - log file path
#! .uses:
# <&9>
# <()>
# <<<>
# <>>>
# [>]
#! .uses.fn:
# <assert> ('-n' "string");
#          Assert a string
# [arg_set] ('_str' "argument");
#           Set with single-quote escape an argument into a variable
# [libfile_n_add] ("natural N" "new string");
#                 For natural N, add line content
# [libfile_n_rem] ("natural N" "line string");
#                 For natural N, remove line string
# [sq_arg] ('1' "single-quotes array of arguments");
#          Get N evaluated argument in a single-quotes array of arguments
#! .gives:
# (0) <"$_file"> - [string];
#                  [modified <$4>]
#! .rc:
# (0) success
# (*) error
# (255) bad input / bad usage / error
#! .rc.fn:
# (arg_set) (*) error
# (assert) (255) bad input
# (libfile_n_add) (*) error
# (libfile_n_rem) (*) error
# (sq_arg) (*) error
#! .desc.ext:
# Multiple operations on the same line are not allowed and error code `255`
# (bad usage) will be returned. EOF additions are parsed in FIFO order
# after all deterministic operations have been executed.
#
# If a path to a valid file ($5) is given, a diff-style log of any changes
# will be appended to it. If $5 is specified but not a valid file,
# error code `255` (bad usage) will be returned.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: File Descriptor".
# > "POSIX.1-2024, Volume: Base Definitions,
#   Section: Directory Structure and Devices,
#   Subsection: Directory Structure and Files".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Appending Redirected Output".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Command Substitution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Duplicating an Output File Descriptor".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: exec".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Here-Document".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Redirecting Output".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Redirection".
#.
libfile_n() {
    [ "$#" -ge 2 ] || return 255

    # Parse the operations into a predictable, shell-performant format.
    # The original positional parameters will shift by 1.
    set -- '' "$@"; while :; do
        case "$2" in
            '-')
                arg_set _str "$3" || return "$?"

                _list="'-' '0' $_str"
                _shift=2
            ;;
            '-a' | '-r' | '-s')
                assert -natural-n "$3" || return 255

                # Assert no multiple operations for the same line.
                case "$1" in
                    *"'-a' '$3'"* | \
                    *"'-r' '$3'"* | \
                    *"'-s' '$3'"*)
                        return 255
                    ;;
                esac
            ;;
            *)
                break
            ;;
        esac

        case "$2" in
            '-a')
                arg_set _str "$4" || return "$?"

                _list="'-a' '$3' $_str"
                _shift=3
            ;;
            '-r')
                _list="'-r' '$3'"
                _shift=2
            ;;
            '-s')
                arg_set _str "$4" || return "$?"

                _list="'-s' '$3' $_str"
                _shift=3
            ;;
        esac

        _op_list="$1"; shift "$((1 + _shift))"
        set -- "$_op_list $_list" "$@"
    done

    # Assert the log file if specified.
    if [ "$3" ] && [ ! -f "$3" ]; then
        return 255
    fi

    # Open the log file (or /dev/null) using file descriptor `9`. The usage of
    # a file descriptor avoids open/close and related syscall overhead,
    # and also allows us to drop the log file positional parameter.
    exec 9>> "${3:-/dev/null}" || return "$?"

    # Save the file content into $_str, remove its positional parameter,
    # and set custom additional required positional parameters.
    #
    # The current positional parameters become:
    # $1 = op_list
    # $2 = orig_offset
    # $3 = cur_offset (required for diff/log; tracks current line)
    # $4 = delta_offset (required for diff/log; tracks consecutive difference)
    _str="$2"; set -- "$1" 1 1 0

    # Store the output of `printf` in $_file using command substitution.
    # The custom `x` character at the end and its subsequent removal
    # outside the command substitution preserves any trailing <newline>
    # characters stripped by command substitution.
    _file=$(
        # Modify the file content.
        #
        # Our optimized op_list is FIFO and the line numbers shall be asserted
        # against orig_offset.
        #
        # Our diff algorithm is by definition streaming and FIFO-driven,
        # heavily contrasting with a deferred hunk approach and/or LCS
        # (longest common subsequence; ex. `diff -u`).
        while IFS= read -r _line; do
            # $1 = op_list
            # $2 = orig_offset
            case "$1" in
                *"'-a' '$2'"*)
                    # Preserve as $5 the current original $_line
                    # only for the current iteration.
                    set -- "$1" "$2" "$3" "$4" "$_line"

                    # $1 = op_list
                    # $2 = orig_offset
                    #
                    # Acquire the relevant string for our orig_offset line
                    # into $_arg.
                    sq_arg 1 "${1#*"'-a' '$2'"}" || return "$?"

                    # $3 = cur_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    libfile_n_add "$3" "$_arg" || return "$?"

                    # $_offset (cur_offset) already acts as a delta_offset;
                    # set $_delta=0.
                    _delta=0

                    # $5 = $_line
                    #
                    # The log ($_log) and the added string ($_str)
                    # always end with a <newline> character.
                    printf "%s" "$_log" >&9
                    printf "%s\n" "$_str$5"
                ;;
                *"'-r' '$2'"*)
                    # $3 = cur_offset
                    # $4 = delta_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    #
                    # For multiple consecutive removals, delta_offset is used
                    # in combination with cur_offset; essentially,
                    # any consecutive line removal operations become
                    # offset-aware for as long as the removal operations
                    # span for.
                    libfile_n_rem "$(($3 + $4))" "$_line" || return "$?"

                    # $4 = delta_offset
                    #
                    # Increment delta_offset for any consecutive removals to
                    # become offset-aware.
                    _delta="$(($4 + 1))"

                    # The log always ends with a <newline> character.
                    printf "%s" "$_log" >&9
                ;;
                *"'-s' '$2'"*)
                    # $3 = cur_offset
                    # $4 = delta_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    #
                    # For multiple consecutive removals, delta_offset is used
                    # in combination with cur_offset; essentially,
                    # any consecutive line removal operations become
                    # offset-aware for as long as the removal operations
                    # span for.
                    libfile_n_rem "$(($3 + $4))" "$_line" || return "$?"

                    # Preserve $_log, $_offset, and $_str as $5, $6, and $7,
                    # respectively.
                    set -- "$1" "$2" "$3" 0 "$_log" "$_offset" "$_str"

                    # $1 = op_list
                    # $2 = orig_offset
                    #
                    # Acquire the relevant string for our orig_offset line
                    # into $_arg.
                    sq_arg 1 "${1#*"'-s' '$2'"}" || return "$?"

                    # $3 = cur_offset
                    # $5 = $_log
                    # $6 = $_offset
                    # $7 = $_str
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    # The old values always end with a <newline> character.
                    libfile_n_add "$3" "$_arg" || return "$?"
                    _log="$5$_log"
                    _offset="$(($6 + _offset))"
                    _str="$7$_str"

                    # $_offset (cur_offset) already acts as a delta_offset;
                    # set $_delta=0.
                    _delta=0

                    # The log ($_log) and the replaced string ($_str)
                    # always end with a <newline> character.
                    printf "%s" "$_log" >&9
                    printf "%s" "$_str"
                ;;
                *)
                    printf "%s\n" "$_line"

                    _offset=0; _delta=0
                ;;
            esac

            # $1 = op_list
            # $2 = orig_offset
            # $3 = cur_offset
            set -- "$1" "$(($2 + 1))" "$(($3 + 1 + _offset))" "$_delta"
        done \
<<EOF
$_str
EOF

        # $1 = op_list
        # $3 = cur_offset
        set -- "$1" "$3"

        # Parse EOF additions.
        while :; do
            # $1 = op_list
            case " $1" in
                *"'-' '0'"*)
                    # Strip and set the modified op_list as $1.
                    _list=" $1"; set -- "${_list#*"'-' '0'"}" "$2"

                    # $1 = op_list
                    #
                    # Acquire the first argument of the modified op_list
                    # into $_arg.
                    sq_arg 1 "$1" || return "$?"

                    # $2 = cur_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    libfile_n_add "$2" "$_arg" || return "$?"

                    # The log ($_log) and the added string ($_str)
                    # always end with a <newline> character.
                    printf "%s" "$_log" >&9
                    printf "%s" "$_str"
                ;;
                *)
                    break
                ;;
            esac

            # $1 = op_list
            # $2 = cur_offset
            set -- "$1" "$(($2 + _offset))"
        done

        printf "%s" x
    ) && \
    _file="${_file%?}" && \
    _file="${_file%?}"

    set -- "$?"

    # Release file descriptor `9` to close the associated log file.
    if [ "$1" = 0 ]; then
        exec 9>&-; set -- "$?"
    else
        exec 9>&-
    fi

    return "$1"
}

#! .desc:
# Match `-`-delimited short/long option without an option argument
#! .params (<2+>):
# <[$1]> - option
# [$2] - -* (short)
# [$3] - --* (long)
#! .rc:
# (0) true
# (1) false
#! .ec:
# (255) input error
#.
sopt() {
    [ "$#" -ge 2 ] || exit 255

    # -> Assert $1 is a `-`-delimited short/long option;
    # -> Assert $2/$3 (whichever applies) is a `-`-delimited short/long option;
    # -> Assert (set) the relevant positional parameter is second in position;
    # -> Assert $1 matches $2 in the relevant, standard way.
    case "$1" in
        '--'*)
            [ "${#1}" -gt 2 ] || return 1

            case "$3" in
                '--'*)
                    [ "${#3}" -gt 2 ] || exit 255

                    set -- "$1" "$3"
                ;;
                *)
                    [ ! "$3" ] || exit 255

                    case "$2" in
                        '--'*) [ "${#2}" -gt 2 ] || exit 255 ;;
                        '-'*) return 1 ;;
                        *) exit 255 ;;
                    esac
                ;;
            esac

            case "$1" in
                "$2") return 0 ;;
            esac
        ;;
        '-'*)
            [ "${#1}" -gt 1 ] || return 1

            case "$2" in
                '--'*) return 1 ;;
                '-'*) [ "${#2}" = 2 ] || exit 255 ;;
                *) exit 255 ;;
            esac

            case "$1" in
                "$2"*) return 0 ;;
            esac
        ;;
    esac

    return 1
}

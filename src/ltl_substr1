#! .desc:
# Get positional substring, (left of, up to) (N)character(s), in a string
#! .params:
# <$1> - "N"_LTR(
#     '0' - max
#     .
# )
# <"$2"> - left of "X" character(s)
# <$3> - "N"_$2-TL(
#     '0' - max
#     .
# )
# <"$4"> - up to "X" character(s)
# <"$5"> - string
# [$6] - options(
#     '-stripl' - strip all leading whitespace characters
#     '-stript' - strip all trailing whitespace characters
#     '-ltstrip' - strip all leading/trailing whitespace characters
#     .
# )
# [$7] - string_options(
#     '-keepl' - keep $2
#     '-keepu' - keep $4
#     '-lukeep' - keep $2/$4
#     .
# )
# [$8] - accuracy(
#     '-verifyexp' - verify the expansion
#     .
# )
# [$9] - type(
#     '-nout' - no output
#     .
# )
#! .gives:
# (0) <"$_str"> - string;
#                 substring
# [$_i] - integer;
#         iterations completed
#! .rc:
# (0) substring | incorrect substring ($1/$3 > $2/$4)
# (1) empty <unspecified/incorrect> expansion
# (2) unspecified <empty/incorrect> expansion
# (255) bad input
#! .rc (accuracy '6'):
# (0) substring
# (1) unspecified expansion ($2 is the first character by the given ruleset)
# (2) unspecified expansion (! $2)
# (3) incorrect expansion ($1 > $2)
# (4) empty expansion ($2..$4)
# (5) unspecified expansion (! $4)
# (6) incorrect expansion ($3 > $4)
# (255) bad input
#.
ltl_substr1() {
    case :$1${1#*[!0123456789]} in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    case :$3${3#*[!0123456789]} in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$3$3") : ;;
        *) return 255 ;;
    esac

    _str="$5"

    case "$6$7$8" in
        *'-verifyexp'*)
            case $1 in
                0)
                    case "$_str" in
                        *"$2"*"$2"*) : ;;
                        "$2"*) return 1 ;;
                        *"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _str="${_str%"$2"*}"
                ;;
                *)
                    case $1:"$_str" in
                        1:"$2"*) return 1 ;;
                        "$1":*"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$1" ]; do
                        _sfix="${_sfix#*"$2"}"

                        case "$_sfix" in
                            *"$2"*) : ;;
                            *) [ "$((_i + 1))" -eq "$1" ] || return 3 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str%"$2$_sfix"}"
                ;;
            esac

            case $3 in
                0)
                    case "$_str" in
                        *"$4"*"$4"*) : ;;
                        *"$4") return 4 ;;
                        *"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _str="${_str#*"$4"}"
                ;;
                *)
                    case $3:"$_str" in
                        1:*"$4") return 4 ;;
                        "$3":*"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _pfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _pfix="${_pfix%"$4"*}"

                        case "$_pfix" in
                            *"$4"*) : ;;
                            *) [ "$((_i + 1))" -eq "$3" ] || return 6 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str#"$_pfix$4"}"
                ;;
            esac
        ;;
        *)
            case $1 in
                0)
                    _str="${_str%"$2"*}"
                ;;
                *)
                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$1" ]; do
                        _sfix="${_sfix#*"$2"}"
                        _i=$((_i + 1))
                    done

                    _str="${_str%"$2$_sfix"}"
                ;;
            esac

            [ "$_str" = "$5" ] && return 2
            _old_str="$_str"

            case $3 in
                0)
                    _str="${_str#*"$4"}"
                ;;
                *)
                    _pfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _pfix="${_pfix%"$4"*}"
                        _i=$((_i + 1))
                    done

                    _str="${_str#"$_pfix$4"}"
                ;;
            esac

            [ "$_str" = "$_old_str" ] && return 2
        ;;
    esac

    [ "$_str" ] || return 1

    case "$6" in
        '-stripl')
            _str="${_str#"${_str%%[! ]*}"}"
        ;;
        '-stript')
            _str="${_str%"${_str##*[! ]}"}"
        ;;
        '-ltstrip')
            _str="${_str#"${_str%%[! ]*}"}"
            _str="${_str%"${_str##*[! ]}"}"
        ;;
    esac

    case "$6$7" in
        *'-keepl'*) _str="$_str$2" ;;
        *'-keepu'*) _str="$4$_str" ;;
        *'-lukeep'*) _str="$4$_str$2" ;;
    esac

    case "$6$7$8$9" in
        *'-nout'*) : ;;
        *) printf "%s" "$_str" ;;
    esac
}
